/**
 * @file kif_flattener.hpp
 * @author Sumedh Ghaisas
 *
 * Declaration of KIFFlattener class.
 */
#ifndef KIF_FLATTENER_HPP_INCLUDED
#define KIF_FLATTENER_HPP_INCLUDED

#include <string>
#include <set>

#include <gdlparser/kif.hpp>
#include <gdlparser/data_types.hpp>
#include <gdlreasoner/knowledgebase.hpp>

namespace gdlreasoner
{
/**
 * This class represents KIF flattener. It converts all the clause to ground form,
 * or in other words removes all the variables. KIFFlattener takes KIF object as its input.
 * @note This flattener will remove all the occurrences data relations (relations which are
 * independent of true and does) e.g. successor, index etc. from facts and clauses as they are
 * no longer required when description is flattened. Dependency graph generated by KIF is used
 * extensively in flattening. Using dependency graph bottom up dependency parsing is done which
 * completes in only one iteration.
 * Sample use -
 * @code
 * KIF kif;
 * kif.AddFile("3puzzle.kif");
 * kif.Parse();
 *
 * KIFFlattener kf;
 * kf.Flatten(kf);
 *
 * std::list<Fact> facts = kf.GetFlattenedFacts();
 * std::list<Clause> clauses = kf.GetFlattenedClauses();
 *
 * kf.PrintToFile("3puzzle_flattened.kif");
 * @endcode
 */
class KIFFlattener
{
    //! useful imports
    typedef gdlparser::DGraphNode DGraphNode;
    typedef gdlparser::Clause Clause;
    typedef gdlparser::Fact Fact;
    typedef gdlparser::Argument Argument;

public:
    //! empty constructor
    KIFFlattener(bool isDebuggingSymbol = true)
        : isDebuggingSymbol(isDebuggingSymbol) {}

    //! flattened the knowledge in given KIF object and stores the flattened knowledge
    void Flatten(const gdlparser::KIF& kif);

    //! print the current flattened knowledge
    bool PrintToFile(const std::string& filename);

    //! get all facts
    const std::list<Fact>& GetFlattenedFacts() const { return flattened_facts; }
    //! get all clauses
    const std::list<Clause>& GetFlattenedClauses() const { return flattened_clauses; }

private:
    //! performs simple DFS and returns all the relations traversed
    void DFSMarking(const DGraphNode* node, std::set<std::string>& marked);

    //! flattenes the relation represented by given dependency graph node
    //! all the flattened clauses and facts of given relation are added to
    //! appropriate lists.
    void FlattenRelation(const DGraphNode* n, const KnowledgeBase& all_kb,
                         const std::set<std::string>& state_independent,
                         KnowledgeBase& m_kb,
                         std::list<Clause>& f_clauses,
                         std::list<Fact>& f_facts);

    //! pre-processes clause before flattening
    Clause* ProcessClause(Clause& c, const std::set<std::string>& state_independent);
    //! pre-processes argument before flattening
    Argument* ProcessPremiss(Argument* arg, const std::set<std::string>& state_independent);

    //! returns new argument, copy of the given argument but only shallow copy for variables
    Argument* SpecialArgCopy(Argument* arg, std::set<Argument*>& vars);

    //! deletes arguments created by SpecialArgCopy
    //! does not delete variables
    void SpecialArgDelete(Argument* arg);
    //! deletes clauses created with SpecialArgCopy
    //! does not delete variables
    void SpecialClauseDelete(Clause* c);

    //! removes all the data relations from the clause
    //! also removes distinct, role, input, base from the premisses as they are no longer required
    //! after flattening
    Clause* RemoveDataFromClause(Clause* c, const std::set<std::string>& state_independent);
    //! removes all the data relations from the argument
    //! used when 'or' is encountered in the premiss
    Argument* RemoveDataFromArgument(Argument* arg, const std::set<std::string>& state_independent);

    //! stores flattened facts
    std::list<Fact> flattened_facts;
    //! stores flattened clauses
    std::list<Clause> flattened_clauses;

    const bool isDebuggingSymbol;
};

} // namespace gdlreasoner


#endif // KIF_FLATTENER_HPP_INCLUDED
