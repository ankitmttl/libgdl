/**
 * @file dgraph.hpp
 * @author Sumedh Ghaisas
 *
 * Declaration RawDGraph and DGraph class.
 */
#ifndef _LIBGDL_CORE_DGRAPH_HPP_INCLUDED
#define _LIBGDL_CORE_DGRAPH_HPP_INCLUDED

#include <iostream>
#include <map>
#include <stack>
#include <set>
#include <list>
#include <atomic>
#include <boost/intrusive_ptr.hpp>

#include <libgdl/core/symbol_table/symbol_table.hpp>
#include <libgdl/core/data_types/error_type.hpp>

#include "dgraph_node.hpp"

namespace libgdl
{
namespace core
{

/**
 * This class represents dependency graph generated by KIF parser while parsing
 * the input. Dependency graph stores the dependency between all the predicates
 * and the location where it occurs for debugging purposes. Dependency graph is
 * used for GDL syntactical checks, for example checking if input is not
 * not does, checking if all the clauses satisfy Definition 15 given in GDL
 * specs. Dependency graph is also used in KIFFlattener for one pass flattening.
 * RawDGraph supports intrusive pointers which is used by DGraph
 *
 * @see KIF, KIFFlattener, DGraph
 */
class RawDGraph
{
 public:
  //! Empty Constructor
  //! Initializes the counter to zero
  //!
  //!
  RawDGraph()
    : count(0u), current_id(0) {}

  //! Destructor
  ~RawDGraph();

  //! Adds node to the dependency graph
  //! Returns success state
  //!
  //! \param id SymbolTable entry of the identifier
  //! \return bool
  //!
  //!
  bool AddNode(size_t id);

  //! Add dependency edge between given relations
  //! Negative dependency is given by isNot
  //!
  //! \param head The Dependant
  //! \param rel The predicate on which it is dependent
  //! \param c Clause in which this dependency occurs
  //! \param arg Argument of clause in which this dependency is observed
  //! \param isNot If the dependency is negative
  //! \return bool
  //!
  //!
  bool AddDependency(size_t head,
                     size_t rel,
                     const Clause* c,
                     const Argument* arg,
                     bool isNot = false);

  //! Check if cycles with negative dependency are presents
  //! According to GDL specs, cycles with negative dependency are invalid
  //! Also checks if all the clauses satisfy Definition 15 of GDL specs
  //! Returns list of errors occurred
  //!
  //! \param symbol_table SymbolTable for debugging
  //! \return std::list<ErrorType>
  //!
  //!
  std::list<ErrorType> CheckCycles(const SymbolTable& symbol_table);

  //! Checks for invalid recursive dependency
  //! For further information check GDL specs
  //! Returns list of errors occurred
  //!
  //! \return std::list<ErrorType>
  //!
  //!
  std::list<ErrorType> CheckRecursiveDependencies();

  //! Get dependency graph
  //!
  //! \return const std::map<size_t, DGraphNode*>&
  //!
  //!
  const std::map<size_t, DGraphNode*>& GetGraph() const
  {
    return graph;
  }

  //! Returns string representation of this dependency graph using the symbol
  //! table. This function is used by SymbolDecodeStream to print DGraph
  //!
  //! \param symbol_table const SymbolTable&
  //! \return std::string
  //!
  //! @see SymbolDecodeStream
  //!
  std::string DecodeToString(const SymbolTable& symbol_table) const;

  //! Refernce count stored in atomic variable (useful for multi-threading)
  std::atomic_size_t count;

 private:
  //! Finds strongly connected components in this dependency graph
  //! This function uses Tarjan's SCC algorithm.
  //! For further information refer to
  //!
  //! @href http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
  //!
  //! \param v The starting node
  //! \param nstack Stack of nodes visited
  //! \param nset Set of nodes visited
  //! \param scc Vector of strongly connected components(set) as return
  //!
  //!
  void StrongConnect(DGraphNode* v,
                     std::stack<DGraphNode*>& nstack,
                     std::set<DGraphNode*>& nset,
                     std::vector<std::set<DGraphNode*> >& scc);

  //! Check if given clause satisfies definition 15 of GDL specs.
  //!
  //! \param clause Clause to check
  //! \param arg Argument of clause to check
  //! \param scc The strongly connected component set for checking dependencies
  //! \param symbol_table SymbolTable for verbose errors
  //! \param errors List of errors occurred
  //!
  //!
  void CheckDef15(const Clause* clause,
                  const Argument* arg,
                  const std::set<DGraphNode*>& scc,
                  const SymbolTable& symbol_table,
                  std::list<ErrorType>& errors);

  //! graph represented as map
  std::map<size_t, DGraphNode*> graph;

  //! the id to be assigned to new node
  size_t current_id;
}; // class RawDGraph

//! Intrusive pointer release function for RawDGraph
//! Decrements reference count of RawDGraph object
//!
//! \param p object to decrement
//!
//!
inline void intrusive_ptr_release(RawDGraph* p)
{
   if (--p->count == 0u)
        delete p;
}

//! Intrusive pointer add function for RawDGraph
//! Increments reference count
//!
//! \param p object to increment
//!
//!
inline void intrusive_ptr_add_ref(RawDGraph* p)
{
  ++p->count;
}

/**
 * Represents dependency graph. DGraph is a intrusive pointer implementation
 * which wraps RawDGraph. DGraph is implemented in such a way as to
 * abstract the intrusive pointer from user.
 *
 * @see RawDGraph
 */
class DGraph : public boost::intrusive_ptr<RawDGraph>
{
 public:
  //! Constructs empty dependency graph
  DGraph()
    : boost::intrusive_ptr<RawDGraph>(new RawDGraph()) {}

  //! Constructs dependency graph from pointer of raw dependency graph
  //!
  //! \param graph Pointer to raw dependency graph
  //!
  DGraph(RawDGraph* graph)
    : boost::intrusive_ptr<RawDGraph>(graph) {}

  //! Adds node to the dependency graph
  //! Returns success state
  //!
  //! \param id SymbolTable entry of the identifier
  //! \return bool
  //!
  //!
  bool AddNode(size_t id) { return get()->AddNode(id); }

  //! Add dependency edge between given relations
  //! Negative dependency is given by isNot
  //!
  //! \param head The Dependant
  //! \param rel The predicate on which it is dependent
  //! \param c Clause in which this dependency occurs
  //! \param arg Argument of clause in which this dependency is observed
  //! \param isNot If the dependency is negative
  //! \return bool
  //!
  //!
  bool AddDependency(size_t head,
                     size_t rel,
                     const Clause* c,
                     const Argument* arg,
                     bool isNot = false)
  {
    return get()->AddDependency(head, rel, c, arg, isNot);
  }

  //! Check if cycles with negative dependency are presents
  //! According to GDL specs, cycles with negative dependency are invalid
  //! Also checks if all the clauses satisfy Definition 15 of GDL specs
  //! Returns list of errors occurred
  //!
  //! \param symbol_table SymbolTable for debugging
  //! \return std::list<ErrorType>
  //!
  //!
  std::list<ErrorType> CheckCycles(const SymbolTable& symbol_table)
  {
    return get()->CheckCycles(symbol_table);
  }

  //! Checks for invalid recursive dependency
  //! For further information check GDL specs
  //! Returns list of errors occurred
  //!
  //! \return std::list<ErrorType>
  //!
  //!
  std::list<ErrorType> CheckRecursiveDependencies()
  {
    return get()->CheckRecursiveDependencies();
  }

  //! Get dependency graph
  //!
  //! \return const std::map<size_t, DGraphNode*>&
  //!
  //!
  const std::map<size_t, DGraphNode*>& GetGraph() const
  {
    return get()->GetGraph();
  }

  //! Returns string representation of this dependency graph using the symbol
  //! table. This function is used by SymbolDecodeStream to print DGraph
  //!
  //! \param symbol_table const SymbolTable&
  //! \return std::string
  //!
  //! @see SymbolDecodeStream
  //!
  std::string DecodeToString(const SymbolTable& symbol_table) const
  {
    return get()->DecodeToString(symbol_table);
  }
}; // class DGraph

}; // namespace core
}; // namespace libgdl

#endif // _LIBGDL_CORE_DGRAPH_HPP_INCLUDED
